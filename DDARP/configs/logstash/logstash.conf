input {
  # Read DDARP logs from JSON files
  file {
    path => "/var/log/ddarp/*.json"
    start_position => "beginning"
    codec => "json"
    tags => ["ddarp", "json_log"]
  }

  # Read container logs
  file {
    path => "/var/log/containers/*.log"
    start_position => "beginning"
    tags => ["container", "docker"]
  }

  # Listen for direct log shipping from DDARP nodes
  tcp {
    port => 5000
    codec => json_lines
    tags => ["ddarp", "tcp_input"]
  }

  # UDP input for syslog-style messages
  udp {
    port => 5514
    tags => ["syslog", "udp_input"]
  }

  # Beats input for system metrics
  beats {
    port => 5044
    tags => ["beats", "metrics"]
  }
}

filter {
  # Parse DDARP structured logs
  if "ddarp" in [tags] {
    if [log_category] {
      mutate {
        add_field => { "[@metadata][index_suffix]" => "%{log_category}" }
      }
    }

    # Parse correlation ID for tracing
    if [correlation_id] {
      mutate {
        add_field => { "trace_id" => "%{correlation_id}" }
      }
    }

    # Extract node information
    if [node_id] {
      mutate {
        add_field => { "node" => "%{node_id}" }
      }
    }

    # Parse OWL measurements
    if [log_category] == "OWL_MEASUREMENT" {
      if [details][latency_ms] {
        mutate {
          add_field => { "latency" => "%{[details][latency_ms]}" }
          convert => { "latency" => "float" }
        }
      }
      if [details][jitter_ms] {
        mutate {
          add_field => { "jitter" => "%{[details][jitter_ms]}" }
          convert => { "jitter" => "float" }
        }
      }
      if [details][packet_loss_ratio] {
        mutate {
          add_field => { "packet_loss" => "%{[details][packet_loss_ratio]}" }
          convert => { "packet_loss" => "float" }
        }
      }
      if [details][peer_id] {
        mutate {
          add_field => { "peer" => "%{[details][peer_id]}" }
        }
      }
    }

    # Parse path computation events
    if [log_category] == "PATH_COMPUTATION" {
      if [details][duration_ms] {
        mutate {
          add_field => { "computation_time" => "%{[details][duration_ms]}" }
          convert => { "computation_time" => "float" }
        }
      }
      if [details][destination] {
        mutate {
          add_field => { "destination" => "%{[details][destination]}" }
        }
      }
      if [details][algorithm] {
        mutate {
          add_field => { "algorithm" => "%{[details][algorithm]}" }
        }
      }
    }

    # Parse BGP events
    if [log_category] == "BGP_EVENT" {
      if [details][neighbor] {
        mutate {
          add_field => { "bgp_neighbor" => "%{[details][neighbor]}" }
        }
      }
      if [details][session_status] {
        mutate {
          add_field => { "bgp_status" => "%{[details][session_status]}" }
        }
      }
      if [details][event_type] {
        mutate {
          add_field => { "bgp_event_type" => "%{[details][event_type]}" }
        }
      }
    }

    # Parse tunnel events
    if [log_category] == "TUNNEL_LIFECYCLE" {
      if [details][peer_id] {
        mutate {
          add_field => { "tunnel_peer" => "%{[details][peer_id]}" }
        }
      }
      if [details][interface] {
        mutate {
          add_field => { "tunnel_interface" => "%{[details][interface]}" }
        }
      }
      if [details][status] {
        mutate {
          add_field => { "tunnel_status" => "%{[details][status]}" }
        }
      }
    }

    # Parse system health events
    if [log_category] == "SYSTEM_HEALTH" {
      if [details][cpu_percent] {
        mutate {
          add_field => { "cpu_usage" => "%{[details][cpu_percent]}" }
          convert => { "cpu_usage" => "float" }
        }
      }
      if [details][memory_percent] {
        mutate {
          add_field => { "memory_usage" => "%{[details][memory_percent]}" }
          convert => { "memory_usage" => "float" }
        }
      }
      if [details][error_type] {
        mutate {
          add_field => { "error_type" => "%{[details][error_type]}" }
        }
      }
    }

    # Add geographic location if available
    if [node_id] =~ /^node[0-9]+$/ {
      if [node_id] == "node1" {
        mutate {
          add_field => { "[geoip][location][lat]" => "40.7128" }
          add_field => { "[geoip][location][lon]" => "-74.0060" }
          add_field => { "[geoip][city_name]" => "New York" }
        }
      } else if [node_id] == "node2" {
        mutate {
          add_field => { "[geoip][location][lat]" => "34.0522" }
          add_field => { "[geoip][location][lon]" => "-118.2437" }
          add_field => { "[geoip][city_name]" => "Los Angeles" }
        }
      } else if [node_id] == "node3" {
        mutate {
          add_field => { "[geoip][location][lat]" => "41.8781" }
          add_field => { "[geoip][location][lon]" => "-87.6298" }
          add_field => { "[geoip][city_name]" => "Chicago" }
        }
      }
    }
  }

  # Parse container logs
  if "container" in [tags] {
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:container_timestamp} %{WORD:container_name} %{GREEDYDATA:container_message}" }
    }

    if [container_name] in ["ddarp-node1", "ddarp-node2", "ddarp-node3"] {
      mutate {
        add_tag => ["ddarp_container"]
      }
    }
  }

  # Parse syslog messages
  if "syslog" in [tags] {
    grok {
      match => { "message" => "%{SYSLOGTIMESTAMP:syslog_timestamp} %{IPORHOST:syslog_server} %{DATA:syslog_program}(?:\\[%{POSINT:syslog_pid}\\])?: %{GREEDYDATA:syslog_message}" }
    }
  }

  # Convert timestamp to @timestamp
  if [timestamp] {
    date {
      match => [ "timestamp", "ISO8601" ]
      target => "@timestamp"
    }
  }

  # Add processing metadata
  mutate {
    add_field => { "[@metadata][processed_at]" => "%{+YYYY-MM-dd'T'HH:mm:ss.SSSZ}" }
    add_field => { "logstash_version" => "8.0.0" }
  }

  # Remove unnecessary fields
  mutate {
    remove_field => [ "host", "path" ]
  }
}

output {
  # Output to Elasticsearch with dynamic index naming
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "ddarp-logs-%{+YYYY.MM.dd}"

    # Use category-specific indices for better organization
    if [@metadata][index_suffix] {
      index => "ddarp-%{[@metadata][index_suffix]}-%{+YYYY.MM.dd}"
    }

    # Template for DDARP indices
    template_name => "ddarp"
    template => "/usr/share/logstash/templates/ddarp-template.json"
    template_overwrite => true
  }

  # Output to file for debugging
  if [@metadata][debug] {
    file {
      path => "/var/log/logstash/ddarp-debug-%{+YYYY-MM-dd}.log"
      codec => json_lines
    }
  }

  # Output metrics to separate index
  if "metrics" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "ddarp-metrics-%{+YYYY.MM.dd}"
    }
  }

  # Dead letter queue for failed processing
  if "_grokparsefailure" in [tags] or "_jsonparsefailure" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "ddarp-failed-%{+YYYY.MM.dd}"
    }
  }

  # Console output for development
  if [log_level] == "DEBUG" {
    stdout {
      codec => rubydebug
    }
  }
}